package com.retail.dolphinpos.data.dao

import androidx.room.Dao
import androidx.room.Insert
import androidx.room.OnConflictStrategy
import androidx.room.Query
import androidx.room.Update
import androidx.room.Transaction
import com.retail.dolphinpos.data.entities.user.BatchEntity
import com.retail.dolphinpos.data.entities.user.BatchLifecycleStatus
import com.retail.dolphinpos.data.entities.user.BatchSyncStatus

/**
 * Data Access Object for Batch operations.
 * 
 * CRITICAL OPERATIONS:
 * - getActiveBatch(): Returns the currently active batch (single source of truth)
 * - closeActiveBatch(): Closes the current active batch
 * - createBatch(): Creates a new batch (must be called after closing previous one)
 */
@Dao
interface BatchDao {
    
    /**
     * Gets the currently active (OPEN) batch for the given register.
     * Returns null if no active batch exists.
     * 
     * This is the single source of truth for which batch orders should attach to.
     */
    @Query("""
        SELECT * FROM batch 
        WHERE registerId = :registerId 
        AND lifecycleStatus = 'OPEN'
        ORDER BY openedAt DESC 
        LIMIT 1
    """)
    suspend fun getActiveBatch(registerId: Int): BatchEntity?
    
    /**
     * Gets active batch by store and register.
     * Used when registerId might not be available but storeId is.
     */
    @Query("""
        SELECT * FROM batch 
        WHERE storeId = :storeId 
        AND registerId = :registerId 
        AND lifecycleStatus = 'OPEN'
        ORDER BY openedAt DESC 
        LIMIT 1
    """)
    suspend fun getActiveBatch(storeId: Int, registerId: Int): BatchEntity?
    
    /**
     * Gets batch by its UUID (primary key)
     * Batch IDs are always generated by POS, never by server
     */
    @Query("SELECT * FROM batch WHERE batchId = :batchId LIMIT 1")
    suspend fun getBatchById(batchId: String): BatchEntity?
    
    /**
     * Gets batch by batch number (human-readable identifier).
     * Used when we have batchNo but need to get the full batch entity.
     */
    @Query("SELECT * FROM batch WHERE batchNo = :batchNo LIMIT 1")
    suspend fun getBatchByBatchNo(batchNo: String): BatchEntity?
    
    /**
     * Gets all batches for a register ordered by open time (newest first)
     */
    @Query("""
        SELECT * FROM batch 
        WHERE registerId = :registerId 
        ORDER BY openedAt DESC
    """)
    suspend fun getAllBatchesByRegister(registerId: Int): List<BatchEntity>
    
    /**
     * Gets batches that need START sync (batch start not yet synced to server).
     * These batches need their batch start operation synced.
     */
    @Query("""
        SELECT * FROM batch 
        WHERE syncStatus = 'START_PENDING'
        ORDER BY openedAt ASC
    """)
    suspend fun getBatchesNeedingStartSync(): List<BatchEntity>
    
    /**
     * Gets batches that need CLOSE sync (batch closed locally but close not synced to server).
     * Only returns batches that are CLOSED and START_SYNCED (batch exists on server).
     */
    @Query("""
        SELECT * FROM batch 
        WHERE lifecycleStatus = 'CLOSED'
        AND syncStatus = 'CLOSE_PENDING'
        ORDER BY closedAt ASC
    """)
    suspend fun getBatchesNeedingCloseSync(): List<BatchEntity>
    
    /**
     * Gets batches eligible for order sync.
     * Orders can only be synced if batch start is synced (START_SYNCED or later, but not FAILED).
     */
    @Query("""
        SELECT * FROM batch 
        WHERE syncStatus IN ('START_SYNCED', 'CLOSE_PENDING', 'CLOSE_SYNCED')
    """)
    suspend fun getBatchesEligibleForOrderSync(): List<BatchEntity>
    
    /**
     * Gets batches that failed to sync (either start or close failed)
     */
    @Query("""
        SELECT * FROM batch 
        WHERE syncStatus = 'FAILED'
        ORDER BY openedAt DESC
    """)
    suspend fun getFailedBatches(): List<BatchEntity>
    
    /**
     * Inserts a new batch.
     * Uses REPLACE strategy to handle conflicts (shouldn't happen with UUIDs, but safe)
     */
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertBatch(batch: BatchEntity)
    
    /**
     * Updates an existing batch.
     * Used for updating sync status, closing batch, etc.
     */
    @Update
    suspend fun updateBatch(batch: BatchEntity)
    
    /**
     * Closes the active batch by updating lifecycle status, closedAt, and closingCashAmount.
     * 
     * Sync status handling:
     * - If batch was START_SYNCED → set to CLOSE_PENDING (close can sync immediately after start sync)
     * - If batch was START_PENDING → keep as START_PENDING (start must sync first, then BatchSyncWorker
     *   will update to CLOSE_PENDING after start sync completes)
     * 
     * This makes the batch CLOSED, allowing a new batch to be created.
     * 
     * IMPORTANT: This operation is atomic to prevent race conditions.
     */
    @Query("""
        UPDATE batch 
        SET lifecycleStatus = 'CLOSED',
            closedAt = :closedAt, 
            closingCashAmount = :closingCashAmount,
            syncStatus = CASE 
                WHEN syncStatus = 'START_SYNCED' THEN 'CLOSE_PENDING'
                WHEN syncStatus = 'START_PENDING' THEN 'START_PENDING'
                ELSE syncStatus
            END
        WHERE batchId = :batchId 
        AND lifecycleStatus = 'OPEN'
    """)
    suspend fun closeBatch(batchId: String, closedAt: Long, closingCashAmount: Double)
    
    /**
     * Updates a closed batch from START_SYNCED to CLOSE_PENDING after batch start sync completes.
     * This is called by BatchSyncWorker when it syncs a batch start that was already closed locally.
     */
    @Query("""
        UPDATE batch 
        SET syncStatus = 'CLOSE_PENDING'
        WHERE batchId = :batchId 
        AND lifecycleStatus = 'CLOSED'
        AND syncStatus = 'START_SYNCED'
    """)
    suspend fun markClosedBatchAsClosePendingAfterStartSync(batchId: String)
    
    /**
     * Updates batch sync status.
     * Used by BatchSyncWorker to mark batch start/close as synced or failed.
     * Note: Room converts enum to String automatically via TypeConverter
     */
    @Query("""
        UPDATE batch 
        SET syncStatus = :syncStatus 
        WHERE batchId = :batchId
    """)
    suspend fun updateBatchSyncStatus(batchId: String, syncStatus: BatchSyncStatus)
    
    /**
     * Updates batch sync status after successful batch start sync.
     * Called when batch start is successfully synced to server.
     * Batch IDs are always generated by POS, so no server batch ID to save.
     */
    @Query("""
        UPDATE batch 
        SET syncStatus = 'START_SYNCED'
        WHERE batchId = :batchId
    """)
    suspend fun markBatchStartAsSynced(batchId: String)
    
    /**
     * Updates batch sync status after successful batch close sync.
     * Called when batch close is successfully synced to server.
     */
    @Query("""
        UPDATE batch 
        SET syncStatus = 'CLOSE_SYNCED'
        WHERE batchId = :batchId
    """)
    suspend fun markBatchCloseAsSynced(batchId: String)
    
    /**
     * Checks if there's an active (OPEN) batch for the register
     */
    @Query("""
        SELECT EXISTS(
            SELECT 1 FROM batch 
            WHERE registerId = :registerId 
            AND lifecycleStatus = 'OPEN'
        )
    """)
    suspend fun hasActiveBatch(registerId: Int): Boolean
    
    /**
     * Transaction: Closes previous active batch and creates a new one.
     * This ensures atomicity - either both operations succeed or both fail.
     * 
     * IMPORTANT: This must be called within a transaction to prevent race conditions
     * where multiple batches could be active simultaneously.
     */
    @Transaction
    suspend fun closePreviousBatchAndCreateNew(
        previousBatchId: String,
        closedAt: Long,
        closingCashAmount: Double,
        newBatch: BatchEntity
    ) {
        closeBatch(previousBatchId, closedAt, closingCashAmount)
        insertBatch(newBatch)
    }
    
    /**
     * Deletes all batches (used for testing or cleanup)
     */
    @Query("DELETE FROM batch")
    suspend fun deleteAllBatches()
}
